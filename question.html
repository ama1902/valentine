<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Big Question</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body class="page page-question" id="pageQuestion">
  <main class="card">
    <h1 class="title">Will you be my Valentine?</h1>

    <p class="subtitle" id="message">
      <!-- Default helper text -->
      Choose wisely‚Ä¶ my heart is on the line üíó
    </p>

    <p class="attempts" aria-live="polite">
      Number of ‚ÄúNo‚Äù attempts: <span id="noCount">0</span>
    </p>

    <div class="btn-row" id="btnRow">
      <a class="btn btn-yes" id="yesBtn" href="response.html">Yes</a>
      <button class="btn btn-no" id="noBtn" type="button">No</button>
    </div>

    <p class="tiny-note">
      <!-- Customize or delete -->
      Tip: ‚ÄúYes‚Äù comes with hugs.
    </p>
  </main>

  <!-- Hearts burst overlay (used when clicking Yes) -->
  <div class="overlay" id="overlay" aria-hidden="true"></div>

<script>
/*
  Interactivity Summary:
  - First click "No": background turns red + achievement message
  - "No" button dodges when cursor gets near (hover/touch)
  - "No" button text cycles through funny phrases
  - Counter increments each attempt
  - After 3 attempts: show "Okay okay! How about 'Yes' instead? ‚ù§Ô∏è"
  - If she persists: "Fine, I'll ask louder..." and then "PLEASE BE MY VALENTINE! ‚ù§Ô∏è"
  - Clicking "Yes": hearts burst then navigate
*/

(() => {
  const page = document.getElementById('pageQuestion');
  const noBtn = document.getElementById('noBtn');
  const yesBtn = document.getElementById('yesBtn');
  const msg = document.getElementById('message');
  const noCountEl = document.getElementById('noCount');
  const btnRow = document.getElementById('btnRow');
  const overlay = document.getElementById('overlay');

  // Phrases for the "No" button text cycling
  const noPhrases = ["Nope!", "Are you sure?", "Really??", "Try Yes instead! üòâ"];
  let phraseIndex = 0;

  // Attempt counter
  let noAttempts = 0;

  // Used to make the dodge effect funny but not too frustrating
  // (We keep the button inside a "play area" around the buttons.)
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

  // Create a "play area" rectangle based on the button row
  function getPlayArea() {
    const r = btnRow.getBoundingClientRect();
    // Expand the rectangle a bit so the button can dodge around
    const padding = 18;
    return {
      left: r.left - padding,
      top: r.top - padding,
      right: r.right + padding,
      bottom: r.bottom + padding
    };
  }

  function updateNoText() {
    noBtn.textContent = noPhrases[phraseIndex];
    phraseIndex = (phraseIndex + 1) % noPhrases.length;
  }

  function setMessageForAttempts() {
    if (noAttempts === 1) {
      msg.textContent = "Achievement Unlocked: Breaking My Heart üíî Try again?";
      page.classList.add('heartbreak'); // turns background red-ish
    } else if (noAttempts === 3) {
      msg.textContent = "Okay okay! How about 'Yes' instead? ‚ù§Ô∏è";
    } else if (noAttempts === 6) {
      msg.textContent = "Fine, I‚Äôll ask louder: Will you be my Valentine?? üò§üíó";
    } else if (noAttempts >= 8) {
      msg.textContent = "PLEASE BE MY VALENTINE! ‚ù§Ô∏è (I‚Äôm on my knees‚Ä¶ metaphorically.)";
      page.classList.add('plead');
    }
  }

  // Move the "No" button to a random spot within the play area.
  function dodgeNoButton() {
    const area = getPlayArea();
    const btnRect = noBtn.getBoundingClientRect();

    // Convert current button position to "relative" within the button row.
    // We'll use transform translate for smoothness.
    const maxX = (area.right - area.left) - btnRect.width;
    const maxY = (area.bottom - area.top) - btnRect.height;

    // Random position
    const randX = Math.random() * maxX;
    const randY = Math.random() * maxY;

    // Current anchor: place relative to button row top-left
    const anchorX = area.left;
    const anchorY = area.top;

    // Compute translate so it lands inside area
    const targetLeft = anchorX + randX;
    const targetTop = anchorY + randY;

    // Figure out current button top-left, then translate by delta
    const currentLeft = btnRect.left;
    const currentTop = btnRect.top;

    const dx = targetLeft - currentLeft;
    const dy = targetTop - currentTop;

    // Clamp the movement a bit so it doesn't teleport too far on small screens
    const clampedDx = clamp(dx, -220, 220);
    const clampedDy = clamp(dy, -160, 160);

    noBtn.style.transform = `translate(${clampedDx}px, ${clampedDy}px)`;
  }

  // "Near hover" detector: if cursor gets close, dodge.
  function handleMouseMove(e) {
    const rect = noBtn.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    const dist = Math.hypot(e.clientX - cx, e.clientY - cy);

    // If cursor is within ~120px, dodge.
    if (dist < 120) dodgeNoButton();
  }

  // Mobile-friendly: on touchstart near the button, dodge.
  function handleTouchStart(e) {
    const t = e.touches[0];
    if (!t) return;

    const rect = noBtn.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    const dist = Math.hypot(t.clientX - cx, t.clientY - cy);

    if (dist < 140) dodgeNoButton();
  }

  // Click "No"
  noBtn.addEventListener('click', () => {
    noAttempts += 1;
    noCountEl.textContent = String(noAttempts);

    // Cycle the text each click (in addition to hover dodges)
    updateNoText();

    setMessageForAttempts();

    // Make it funny-but-not-infinite: after enough tries,
    // slightly reduce dodging so it becomes easier to click Yes.
    if (noAttempts >= 7) {
      // Less dodgy after lots of attempts
      document.removeEventListener('mousemove', handleMouseMove);
      noBtn.classList.add('tired');
    }

    // Small wiggle feedback
    noBtn.classList.remove('wiggle');
    void noBtn.offsetWidth; // restart animation
    noBtn.classList.add('wiggle');
  });

  // Dodge on hover
  noBtn.addEventListener('mouseenter', () => {
    updateNoText();
    dodgeNoButton();
  });

  // Also dodge if user gets near with mouse/touch
  document.addEventListener('mousemove', handleMouseMove, { passive: true });
  document.addEventListener('touchstart', handleTouchStart, { passive: true });

  // Clicking "Yes": hearts burst + smooth transition
  yesBtn.addEventListener('click', (e) => {
    e.preventDefault();

    // Create a burst of hearts
    overlay.classList.add('show');
    for (let i = 0; i < 18; i++) {
      const heart = document.createElement('div');
      heart.className = 'burst-heart';
      heart.textContent = 'üíñ';
      heart.style.left = (40 + Math.random() * 20) + '%';
      heart.style.top = (45 + Math.random() * 10) + '%';
      heart.style.transform = `translate(-50%, -50%) rotate(${Math.random()*40-20}deg)`;
      heart.style.animationDelay = (Math.random() * 0.2) + 's';
      overlay.appendChild(heart);
    }

    // Navigate after a short celebratory moment
    setTimeout(() => {
      window.location.href = yesBtn.href;
    }, 650);
  });
})();
</script>
</body>
</html>
